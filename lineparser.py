import output
from typing import Callable

_comment = lambda comment = '': '\n'.join(['; ' + line for line in comment.split('\n')]) + '\n'
    
def _parse_version(line):
    if line not in ['vs_1_0', 'vs_1_1', 'vs_1_2', 'vs_2_0', 'vs_2_1', 'vs_2_2', 'vs_3_0']:
        raise Exception(f'Only vs_3_0 or lower is supported, got {line}')
    else: 
        return [_comment('Vertex Shader generated by dxbc2pica 0.0.1'), _comment(f'd3d version: {line}'), _comment()]

def _parsebreak(opcode, operands) -> list[str]:
    if len(opcode) == 1:
        return [f'{opcode[0]}\n']
    else:
        return [f'cmp {operands[0]}, {opcode[1]}, {opcode[1]}, {operands[1]}\n', 'breakc cmp.x\n']

def _parsedcl(opcode, operands) -> list[str]: 
    if operands[0] in ['2d', 'cube', 'volume', '3d']: # texture samplers
        raise Exception("Texture samplers not supported")
    
    # output reg being set
    outopcode = '.out -' if ('o' in operands[0]) else '.in'

    if opcode[1] == 'texcoord': # force there to be a number
        return [f'{outopcode} {opcode[1]}0 {operands[0]}{output.ignoretab()}\n']
    return [f'{outopcode} {opcode[1]} {operands[0]}{output.ignoretab()}\n']

def _type1(opcode, operands) -> list[str]:
    if 'c' in operands[1] and 'c' in operands[2]:
        return [
            f'mov {operands[0]}, {operands[1]}\n',
            f'{opcode[0]} {operands[0]}, {operands[2]}, {operands[0]}\n'
        ]
    else:
        if 'c' in operands[2]:
            return [f'{opcode[0]} {operands[0]}, {operands[2]}, {operands[1]}\n']
        return [f'{opcode[0]} {operands[0]}, {operands[1]}, {operands[2]}\n']
        
def _type1i(opcode, operands) -> list[str]:
    if 'c' in operands[1] and 'c' in operands[2]:
        return [
            f'mov {operands[0]}, {operands[1]}\n',
            f'{opcode[0]} {operands[0]}, {operands[2]}, {operands[0]}\n'
        ]
    else:
        return [f'{opcode[0]} {operands[0]}, {operands[1]}, {operands[2]}\n']

def _type1u(opcode, operands) -> list[str]:
    return [f'{opcode[0]} {operands[0]}, {operands[1]}\n']

def _parseif(opcode, operands) -> list[str]:
    return [_comment(f'{opcode} {operands}')]
    
def _parsemad(opcode, operands) -> list[str]:
    numconstants = sum(['c' in op for op in operands])
    # if there are no constants or there is a uniform in either src2 or src3 do nothing
    if sum(['c' in op for op in operands]) == 0 or (numconstants == 1 and 'c' not in operands[1]): return [f'mad {operands[0]}, {operands[1]}, {operands[2]}, {operands[3]}\n']
    return _lineparser['mul'](['mul'], operands) + _lineparser['add'](['add'], [operands[0], operands[0], operands[3]])

def _parsesetp(opcode, operands) -> list[str]:
    return [_comment(f'{opcode} {operands}')]

def _parsesgn(opcode, operands) -> list[str]:
    return [_comment(f'{opcode} {operands}')]
    
_lineparser: dict[str, Callable[[list[str], list[str]], list[str]]] = {
    'abs': lambda opcode, operands: [f'max {operands[0]}, -{operands[0]}\n'],
    'add': _type1,
    'break': _parsebreak,
    'breakp': lambda opcode, operands: [f'breakc {operands[0].replace('p0', 'cmp')}\n'],
    'call': lambda opcode, operands: [f'call {operands[0]}\n'],
    'callnz': lambda opcode, operands: [f'call{'u' if 'b' in operands[1] else 'c'} {operands[1].replace('p0', 'cmp')}, {operands[0]}\n'],
    'crs': lambda opcode, operands: (_ for _ in ()).throw(Exception('crs not supported, make sure your compiler is set not to keep macros')),
    'dcl': _parsedcl,
    'def': lambda opcode, operands: [f'.constf {operands[0]}({operands[1]}, {operands[2]}, {operands[3]}, {operands[4]}{output.ignoretab()})\n'],
    'defb': lambda opcode, operands: (_ for _ in ()).throw(Exception('defb not supported')),
    'defi': lambda opcode, operands: [f'.consti {operands[0]}({operands[1]}, {operands[2]}, {operands[3]}, {operands[4]}){output.ignoretab()}\n'],
    'dp3': _type1,
    'dp4': _type1,
    'dst': _type1i,
    'else': lambda opcode, operands: ['.else\n'],
    'endif': lambda opcode, operands: [f'.end{output.dectab()}\n'],
    'endloop': lambda opcode, operands: [f'.end{output.dectab()}\n'],
    'endrep': lambda opcode, operands: [f'.end{output.dectab()}\n'],
    'exp': lambda opcode, operands: [f'ex2 {operands[0]}, {operands[1]}\n'],
    'expp': lambda opcode, operands: [f'ex2 {operands[0]}, {operands[1]}\n'],
    'frc': lambda opcode, operands: _type1u(['flr'], operands) + _lineparser['sub'](['sub'], [operands[0], operands[1], operands[0]]),
    'if': _parseif,
    'label': lambda opcode, operands: [f' {operands[0]}\n'],
    # 'lit': lambda opcode, operands: f'max {operands[0]}.x, {operands[1]}\n',
    'log': lambda opcode, operands: _type1u(['lg2'], operands),
    'logp': lambda opcode, operands: _type1u(['lg2'], operands),
    'loop': lambda opcode, operands: [f'for {operands[1]}\n'],
    'mad': _parsemad,
    'mov': _type1u,
    'mova': _type1u,
    'mul': _type1,
    'nop': lambda opcode, operands: ['nop\n'],
    'nrm': lambda opcode, operands: _lineparser['dp4'](['dp4'], [operands[0], operands[1], operands[1]]) + _lineparser['rsq'](['rsq'], [operands[0], operands[0]]) + _lineparser['mul'](['mul'], [operands[0], operands[1], operands[0]]),
    'rep': lambda opcode, operands: [f'for {operands[0]}{output.inctab_after()}\n'],
    'ret': lambda opcode, operands: ['jmp'], # incomplete instruction, must be followed by a label
    'rsq': _type1u,
    'setp': _parsesetp,
    'sge': _type1i,
    'sgn': _parsesgn,
    'sincos': lambda opcode, operands: (_ for _ in ()).throw(Exception('sincos not supported')),
    'slt': _type1i,
    'sub': lambda opcode, operands: _lineparser['add'](['add'], [operands[0], operands[1], '-' + operands[2]]),
    'texldl': lambda opcode, operands: (_ for _ in ()).throw(Exception('texldl not supported')),
    'vs': lambda opcode, operands: [_comment(f'version {operands[0]}')],
}

def parse(line) -> str | list[str]:
    # remove leading and trailing whitespace
    line = line.strip()
    
    if line == '': # ignore empty lines
        return ''
    
    # handle comments
    if line.startswith('//'):
        return _comment(line[3:])
    
    # handle version
    if line.startswith('vs_'):
        return _parse_version(line)
    components = line.replace(',', '').split()
    opcode = components[0].split("_")
    operands = components[1:]
    
    return _lineparser[opcode[0]](opcode, operands)